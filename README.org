* Python resultant block evaluation 
This Python library provides the ~block_eval~ function which is similar to the the standard ~eval~ function, but
- can handle multiple statements like the ~exec~ call
- returns the result of the last statement if it is an expression
This library uses only modules available in the standard library, namely
- ~ast~ for analysis of the abstract syntax tree of the block to be evaluated
- ~inspect~ for capturing variable scope in the calling frame to fully emulate ~eval~ behavior
In some ways it is similar how IPython evaluates blocks of code. It can be also thought of as an equivalent of the ~progn~ function in Lisp.
** Example
In this example the factorial of 3 is calculated in a for loop.
#+BEGIN_EXAMPLE
>>> block_eval("""
... f = 1
... for i in range(1, 3+1):
...     f *= i
... f
... """)
6
>>> f * 2
12
#+END_EXAMPLE
Note that
- in normal interactive mode an empty line would have to follow after ~f *= 1~ to close the for loop
- the value of f is returned since it is an expression as is the last statement in the block
- the defined variables are later accessible as they are are evaluated in the current scope.
* Motivation
The Python support in Org-mode Babel provided by ~ob-python.el~ is somewhat lacking, because Python returns the result of evaluating something only if it is an expression. Furthermore, only in interactive mode (which has limitations regarding continuation lines) is the result of the last printed expression available in the ~_~ variable. For this reason ~ob-python.el~ uses hacks like wrapping code in a function and requires ~return~ statements outside of seemingly function code. That leads to code blocks that cannot be simply tangled into a python file and various other issues. ~ob-ipython.el~ solves some of these issues by working with IPython which can evaluate blocks of code, but that requires extra libraries.

Essentially, for better Python support in Org-mode Babel something like the Lisp ~progn~ function is needed in Python. This library tries to provide such a ~progn~ equivalent.

* Implementation
The library uses the ~ast~ library for analyzing and manipulating the abstract syntax tree and the ~inspect~ library to capture the variable scope of the calling frame. If available, the ~ctypes~ FFI library is used to force local variable scope after evaluation due to unreliable Python behavior when changing local scope.
#+BEGIN_SRC python :tangle block_eval.py
import ast
import inspect
import warnings
try:
    import ctypes
except ImportError:
    warnings.warn(
        "ctypes not available, evaluation may not update local variables",
        RuntimeWarning
    )
#+END_SRC

#+RESULTS:
: None

The ~block_eval~ function has a similar signature to the standard ~eval~ function, optionally a block name can be specified which will be used as the ~filename~ argument in ~compile~ calls.
#+BEGIN_SRC python :tangle block_eval.py
def block_eval(code_str, globals_=None, locals_=None, block_name='<string>'):
    """Evaluate a code (block) string and possibly return its result

    The result is the result of the last statement if it is an expression. This
    function is a compromise between exec and eval: It evaluates all the
    statements like exec, but uses eval for the last statement if it is an
    expression and returns its value. If it is not, None is returned (exec mode)
    """
#+END_SRC

#+RESULTS:
: None

The parent frame is searched for global and local variable scope to fully emulate ~eval~ and falls back to the current frame using the standard functions ~globals~ and ~locals~ which should always work.. This is perhaps the hackiest part of the code, but is needed.
#+BEGIN_SRC python :tangle block_eval.py
    # get scope in calling frame to truly emulate eval
    current_frame = inspect.currentframe()
    try:
        parent_frame = current_frame.f_back
        p_globals, p_locals = parent_frame.f_globals, parent_frame.f_locals
    except AttributeError:      # cannot get that frame or its vars
        p_globals, p_locals = locals(), globals() # these should always work
    finally:
        del current_frame       # otherwise might create reference cycle
    if globals_ is not None:
        p_globals = globals_
        # this is documented eval behavior
        p_locals = p_globals if locals_ is None else locals_
#+END_SRC

#+RESULTS:

Finally, the AST of the code block is parsed and it is determined if the last statement is an expression. If it is, the code preceding it is evaluated in ~exec~ mode and then this last expression is evaluated with ~eval~ and the result returned. Otwerwise, the whole block is simply evaluated in ~exec~ mode, which always returns ~None~.
#+BEGIN_SRC python :tangle block_eval.py
    # AST manipulation and evaluation
    code_ast = ast.parse(code_str)
    assert isinstance(code_ast, ast.Module)
    last_stmt = code_ast.body[-1]
    if isinstance(last_stmt, ast.Expr):
        del code_ast.body[-1]
        if len(code_ast.body) > 0:
            exec(compile(code_ast, block_name, 'exec'), p_globals, p_locals)
            locals()            # update local symbol table after eval
        expr = ast.Expression(last_stmt.value)
        final_code = compile(expr, block_name, 'eval')
    else:
        final_code = compile(code_ast, block_name, 'exec')
    ret = eval(final_code, p_globals, p_locals)
#+END_SRC
Before the result is returned, an update of the local variable scope in the parent frame is forced as evaluation in that frame alone may not immediately change the locals. This is bit of a hack, but should mostly work.
#+BEGIN_SRC python :tangle block_eval.py
    # force an update of locals array from locals dict after evaluating in them
    # from http://faster-cpython.readthedocs.org/mutable.html#local-variables
    frame = inspect.currentframe()
    try:
        ctypes.pythonapi.PyFrame_LocalsToFast(ctypes.py_object(frame),
                                              ctypes.c_int(0))
    except:
        warnings.warn(
            "Cannot force update of local variables after evaluation.",
            RuntimeWarning)
    finally:
        del frame
    return ret
#+END_SRC

#+RESULTS:

** Test suite

, some also referencing local variables. Then it is tested with more complicated expressions and then also block statements.
#+BEGIN_SRC python :tangle test_block_eval.py
import unittest
from textwrap import dedent

from block_eval import block_eval

class TestBlockEval(unittest.TestCase):
#+END_SRC

#+RESULTS:

The ~block_eval~ function is first tested on a simple expression.
#+BEGIN_SRC python :tangle test_block_eval.py
    def test_simple_expr(self):
        ret = block_eval("6 * 7")
        self.assertEqual(ret, 42)
#+END_SRC

#+RESULTS:
: None

Then the referencing of a local variable in a simple expression is tested.
#+BEGIN_SRC python :tangle test_block_eval.py
    def test_simple_expr_with_var(self):
        a = 6
        ret = block_eval("a * 7")
        self.assertEqual(ret, 42)
#+END_SRC

#+RESULTS:
: None

Then a more complicated expression is tested.
#+BEGIN_SRC python :tangle test_block_eval.py
    def test_complicated_expr(self):
        alpha = 1.0 / 137
        ret = block_eval("alpha.is_integer() is False")
        self.assertIs(ret, True)
#+END_SRC

#+RESULTS:
: None

A for loo block is tested, it should not return anything as the last statement is not an expression.
#+BEGIN_SRC python :tangle test_block_eval.py
    def test_non_returning_block(self):
        ret = block_eval(dedent("""
        for i in range(3):
            i * 3
        """))
        self.assertIs(ret, None)
#+END_SRC

#+RESULTS:
: None

This final block returns a result as the last statement is an expression. Referencing varibales defined in the block is also tested.
#+BEGIN_SRC python :tangle test_block_eval.py
    def test_returning_block(self):
        ret = block_eval(dedent("""
        f = 1
        for i in range(1, 3+1):
            f *= i
        f
        """))
        self.assertEqual(ret, 6)
        self.assertEqual(f, ret)
#+END_SRC

#+RESULTS:
: None

